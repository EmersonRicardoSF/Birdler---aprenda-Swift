<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <p>O Gerenciamento Automático de Memória (Automatic Reference Counting - ARC) é um mecanismo do Swift para gerenciar a memória automaticamente, rastreando e gerenciando a contagem de referências aos objetos. No contexto do UIKit, é crucial entender como o ARC funciona para evitar problemas como vazamentos de memória (memory leaks) e ciclos de referência (retain cycles).</p>

    <h2>Conceitos Básicos do ARC</h2>

    <h3>Contagem de Referências</h3>
    <p>Cada vez que uma instância de uma classe é criada, o ARC aloca memória para essa instância e mantém uma contagem de referências (reference count). Sempre que uma referência a essa instância é criada, a contagem aumenta. Quando a referência é removida, a contagem diminui. Quando a contagem chega a zero, o ARC desaloca a memória da instância.</p>

    <h3>Tipos de Referências</h3>
    <ul>
        <li><strong>Strong</strong>: É a referência padrão em Swift. Ela mantém a contagem de referências e garante que o objeto não seja desalocado enquanto houver uma referência forte a ele.</li>
        <li><strong>Weak</strong>: Não incrementa a contagem de referências. Usada principalmente para evitar ciclos de referência. Deve ser sempre declarada como opcional (<code>optional</code>) porque pode se tornar <code>nil</code> quando o objeto ao qual se refere é desalocado.</li>
        <li><strong>Unowned</strong>: Similar à <code>weak</code>, mas não é opcional. Usada quando a referência é esperada para nunca ser <code>nil</code> após ser inicializada.</li>
    </ul>

    <h2>Evitando Ciclos de Referência</h2>
    <p>Ciclos de referência ocorrem quando duas ou mais instâncias de classe mantêm referências fortes entre si, impedindo que o ARC desalocar qualquer uma delas. Isso leva a vazamentos de memória.</p>

    <h3>Exemplo de Ciclo de Referência</h3>
    <pre><code>
class Pessoa {
    let nome: String
    var apartamento: Apartamento?
    
    init(nome: String) {
        self.nome = nome
    }
    
    deinit {
        print("\(nome) está sendo desalocado")
    }
}

class Apartamento {
    let numero: Int
    var morador: Pessoa?
    
    init(numero: Int) {
        self.numero = numero
    }
    
    deinit {
        print("Apartamento \(numero) está sendo desalocado")
    }
}

var john: Pessoa? = Pessoa(nome: "John")
var apt: Apartamento? = Apartamento(numero: 101)

john?.apartamento = apt
apt?.morador = john

// Aqui, john e apt se referem fortemente entre si, causando um ciclo de referência.
    </code></pre>

    <h3>Resolvendo Ciclos de Referência</h3>
    <p>Para resolver ciclos de referência, usamos referências fracas (<code>weak</code>) ou sem dono (<code>unowned</code>).</p>
    <pre><code>
class Pessoa {
    let nome: String
    var apartamento: Apartamento?
    
    init(nome: String) {
        self.nome = nome
    }
    
    deinit {
        print("\(nome) está sendo desalocado")
    }
}

class Apartamento {
    let numero: Int
    weak var morador: Pessoa?  // Usamos weak para evitar o ciclo de referência
    
    init(numero: Int) {
        self.numero = numero
    }
    
    deinit {
        print("Apartamento \(numero) está sendo desalocado")
    }
}

var john: Pessoa? = Pessoa(nome: "John")
var apt: Apartamento? = Apartamento(numero: 101)

john?.apartamento = apt
apt?.morador = john

// Agora, quando as variáveis john e apt são definidas como nil, os objetos serão desalocados corretamente.
john = nil
apt = nil
    </code></pre>

    <h2>Uso de ARC no UIKit</h2>
    <p>No desenvolvimento de aplicativos iOS com UIKit, é comum usar o ARC para gerenciar memória automaticamente. No entanto, é importante estar atento a ciclos de referência, especialmente ao trabalhar com closures e delegados.</p>

    <h3>Exemplo com Closures</h3>
    <pre><code>
class ViewController: UIViewController {
    var completionHandler: (() -> Void)?

    override func viewDidLoad() {
        super.viewDidLoad()

        completionHandler = { [weak self] in
            guard let self = self else { return }
            // Código que usa self
        }
    }

    deinit {
        print("ViewController está sendo desalocado")
    }
}
    </code></pre>

    <h2>Conclusão</h2>
    <p>O ARC é uma ferramenta poderosa no Swift para gerenciar memória automaticamente, mas requer atenção para evitar ciclos de referência e vazamentos de memória. Usar referências fracas (<code>weak</code>) e sem dono (<code>unowned</code>) de maneira adequada é crucial para garantir que a memória seja gerenciada de forma eficiente em aplicativos iOS com UIKit.</p>
</body>
</html>
