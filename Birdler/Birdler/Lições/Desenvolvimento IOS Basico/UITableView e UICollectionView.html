<body>
    <p>UITableView e UICollectionView são dois componentes fundamentais do UIKit para exibir coleções de dados em listas e layouts customizáveis. Ambos têm suas particularidades e são usados em diferentes cenários dependendo da necessidade do layout.</p>
    <h2>SEMELHANÇAS</h2>
    <ul>
        <li>Protocolos Delegados:
            <ul>
                <li>Ambos utilizam protocolos delegados (UITableViewDelegate e UITableViewDataSource para UITableView; UICollectionViewDelegate e UICollectionViewDataSource para UICollectionView) para fornecer dados e gerenciar a interação do usuário.</li>
            </ul>
        </li>
        <li>Reuse de Células:
            <ul>
                <li>Ambos usam um sistema de reutilização de células para melhorar a performance e a eficiência na memória. As células são registradas e recuperadas usando identificadores.</li>
            </ul>
        </li>
    </ul>
    <p><code>// UITableView</code></p>
    <code>tableView.register(UITableViewCell.self, forCellReuseIdentifier: "cell")</code>
    <code>let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath)</code>
    <p><code>// UICollectionView</code></p>
    <code>collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: "cell")</code>
    <code>let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath)</code>
    <ul>
        <li>DataSource e Delegate:
            <ul>
                <li>Ambos os componentes utilizam métodos de DataSource para fornecer dados e métodos de Delegate para gerenciar a interação do usuário.</li>
            </ul>
        </li>
        <li>Scroll:
            <ul>
                <li>Ambos suportam rolagem vertical e horizontal. No entanto, a UITableView é geralmente usada para rolagem vertical, enquanto a UICollectionView pode ser configurada para rolar verticalmente ou horizontalmente, dependendo do layout.</li>
            </ul>
        </li>
    </ul>
    <h2>DIFERENÇAS</h2>
    <ul>
        <li>Layout:
            <ul>
                <li>UITableView: Tem um layout fixo e linear, ideal para listas verticais de itens homogêneos.</li>
                <li>UICollectionView: É altamente customizável e pode ser usado para criar layouts complexos como grades (grid), mosaicos (mosaic), rolagem horizontal e layouts personalizados através do uso de UICollectionViewLayout e UICollectionViewFlowLayout.</li>
            </ul>
        </li>
        <li>Seções e Cabeçalhos:
            <ul>
                <li>UITableView: Suporta seções com cabeçalhos e rodapés fixos, fáceis de implementar.</li>
                <li>UICollectionView: Também suporta seções, cabeçalhos e rodapés, mas requer mais configuração e personalização através de UICollectionReusableView.</li>
            </ul>
        </li>
        <li>Flexibilidade:
            <ul>
                <li>UITableView: Menos flexível em termos de layout, mas mais simples de configurar e usar para listas verticais.</li>
                <li>UICollectionView: Muito mais flexível e poderoso, permitindo layouts completamente customizáveis, mas requer mais código e configuração para aproveitar plenamente suas capacidades.</li>
            </ul>
        </li>
        <li>Desempenho:
            <ul>
                <li>UICollectionView: Pode ser mais eficiente em termos de desempenho quando se trabalha com grandes volumes de dados e layouts complexos devido à sua capacidade de reutilização de células e layout personalizado.</li>
                <li>UITableView: É eficiente para listas simples, mas pode se tornar limitada quando se precisa de layouts complexos.</li>
            </ul>
        </li>
        <li>Uso de Layouts Personalizados:
            <ul>
                <li>UITableView: Não suporta layouts personalizados. O layout é sempre uma lista linear de itens.</li>
                <li>UICollectionView: Suporta completamente layouts personalizados. Você pode criar suas próprias subclasses de UICollectionViewLayout para definir comportamentos complexos.</li>
            </ul>
        </li>
        <li>Exemplos de Uso:
            <ul>
                <li>UITableView: Listas de contatos, configurações, listas de tarefas, menus de navegação.</li>
                <li>UICollectionView: Galerias de fotos, grades de produtos, layouts inspirados em revistas, interfaces dinâmicas com layouts customizados.</li>
            </ul>
        </li>
    </ul>
    <h3>UITableView</h3>
    <p><strong>PROPÓSITO:</strong> Usado para exibir uma lista de itens em uma única coluna, com rolagem vertical.</p>
    <p><strong>ESTRUTURA:</strong> Dividido em seções e linhas.</p>
    <p><strong>CASOS DE USO:</strong> Adequado para listas simples com rolagem vertical, como menus de configurações, listas de contatos ou qualquer lista com linhas que podem incluir texto, imagens ou células personalizadas.</p>
    <p><strong>DELEGATES:</strong></p>
    <ul>
        <li>UITableViewDelegate: Gerencia a aparência e o comportamento da tabela.</li>
        <li>UITableViewDataSource: Gerencia os dados e fornece células para a tabela.</li>
    </ul>
    <p><strong>MÉTODOS PRINCIPAIS:</strong></p>
    <ul>
        <li><code>tableView(_:cellForRowAt:)</code>: Fornece uma célula para cada linha.</li>
        <li><code>tableView(_:numberOfRowsInSection:)</code>: Retorna o número de linhas em uma seção.</li>
        <li><code>numberOfSections(in:)</code>: Retorna o número de seções.</li>
        <li><code>tableView(_:didSelectRowAt:)</code>: Lida com a seleção de linhas.</li>
    </ul>
    <p><strong>COMO MONTAR UMA UITableView:</strong></p>
    <p>ADICIONANDO UITableView À INTERFACE</p>
    <p>No Interface Builder (Storyboard):</p>
    <ul>
        <li>Arraste um UITableView para a sua UIViewController.</li>
        <li>Configure as restrições (constraints) para definir o tamanho e a posição da tabela.</li>
    </ul>
    <p>PROGRAMATICAMENTE (SwiftUI):</p>
    <code>let tableView = UITableView(frame: self.view.bounds, style: .plain)</code>
    <code>self.view.addSubview(tableView)</code>
    <p>Configurando o Delegate e o DataSource:</p>
    <p>Conformar sua UIViewController aos protocolos UITableViewDelegate e UITableViewDataSource:</p>
    <code>class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {</code>
    <p>// ...</p>
    <code>}</code>
    <p>Configurar o delegate e o dataSource:</p>
    <code>override func viewDidLoad() {</code>
    <code>super.viewDidLoad()</code>
    <code>tableView.delegate = self</code>
    <code>tableView.dataSource = self</code>
    <code>}</code>
    <p>IMPLEMENTANDO MÉTODOS REQUERIDOS</p>
    <p>UITableViewDataSource:</p>
    <code>func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {</code>
    <code>return items.count // Número de linhas</code>
    <code>}</code>
    <p><code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {</code></p>
    <code>let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath)</code>
    <code>cell.textLabel?.text = items[indexPath.row]</code>
    <code>return cell</code>
    <code>}</code>
    <p>UITableViewDelegate (opcional):</p>
    <code>func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {</code>
    <code>print("Selecionou: \(items[indexPath.row])")</code>
    <code>}</code>
    <p>REGISTRANDO E CONFIGURANDO CÉLULAS</p>
    <p>Registrando uma célula padrão:</p>
    <code>tableView.register(UITableViewCell.self, forCellReuseIdentifier: "cell")</code>
    <p>Usando uma célula personalizada (no Storyboard):</p>
    <ul>
        <li>Crie uma UITableViewCell no Storyboard e defina um identificador.</li>
        <li>No método cellForRowAt, use o identificador para dequeuing:</li>
    </ul>
    <code>let cell = tableView.dequeueReusableCell(withIdentifier: "customCell", for: indexPath) as! CustomTableViewCell</code>
    <p>FUNCIONALIDADES E DETALHES</p>
    <p>Seções (Sections):</p>
    <p>Métodos para gerenciar seções:</p>
    <code>func numberOfSections(in tableView: UITableView) -> Int {</code>
    <code>return sections.count</code>
    <code>}</code>
    <p><code>func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {</code></p>
    <code>return sections[section].title</code>
    <code>}</code>
    <p>CUSTOMIZAÇÃO DE CÉLULAS</p>
    <p>Criando uma célula personalizada:</p>
    <code>class CustomTableViewCell: UITableViewCell {</code>
    <code>@IBOutlet weak var customLabel: UILabel!</code>
    <p>// Configurações adicionais</p>
    <code>}</code>
    <p>Configurando a célula no cellForRowAt:</p>
    <code>let cell = tableView.dequeueReusableCell(withIdentifier: "customCell", for: indexPath) as! CustomTableViewCell</code>
    <code>cell.customLabel.text = items[indexPath.row]</code>
    <p>AÇÕES NAS CÉLULAS</p>
    <p>Deslizar para excluir:</p>
    <code>func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {</code>
    <code>if editingStyle == .delete {</code>
    <code>items.remove(at: indexPath.row)</code>
    <code>tableView.deleteRows(at: [indexPath], with: .automatic)</code>
    <code>}</code>
    <code>}</code>
    <p>ATUALIZAÇÃO DINÂMICA</p>
    <p>Atualizando a tabela:</p>
    <code>tableView.reloadData()</code>
    <p>Inserindo ou removendo linhas:</p>
    <code>tableView.insertRows(at: [indexPath], with: .automatic)</code>
    <code>tableView.deleteRows(at: [indexPath], with: .automatic)</code>
    <p>Exemplo Completo:</p>
    <pre><code>import UIKit
        class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
        @IBOutlet weak var tableView: UITableView!
        
        let items = ["Item 1", "Item 2", "Item 3"]
        
        override func viewDidLoad() {
        super.viewDidLoad()
        tableView.delegate = self
        tableView.dataSource = self
        tableView.register(UITableViewCell.self, forCellReuseIdentifier: "cell")
        }
        
        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return items.count
        }
        
        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath)
        cell.textLabel?.text = items[indexPath.row]
        return cell
        }
        
        func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        print("Selecionou: \(items[indexPath.row])")
        }
        }
    </code></pre>
    <h2>USOS PRÁTICOS</h2>
    <ul>
        <li>LISTAS SIMPLES: Exibir listas de contatos, tarefas, configurações, etc.</li>
        <li>DADOS HIERÁRQUICOS: Organizar dados em seções, como categorias de produtos.</li>
        <li>TABELAS CUSTOMIZADAS: Criar interfaces ricas com células personalizadas, incluindo imagens, botões e outros elementos.</li>
        <li>INTERAÇÃO DO USUÁRIO: Implementar funcionalidades como deslizar para excluir, arrastar para reordenar, e ações em células.</li>
    </ul>
    <h3>UICollectionView</h3>
    <p><strong>PROPÓSITO:</strong> Usado para exibir uma coleção de itens em uma grade ou qualquer layout customizado, com rolagem horizontal ou vertical.</p>
    <p><strong>ESTRUTURA:</strong> Dividido em seções e itens.</p>
    <p><strong>CASOS DE USO:</strong> Adequado para layouts mais complexos como grades de fotos, galerias de imagens ou qualquer coleção que necessite de um layout flexível.</p>
    <p><strong>DELEGATES:</strong></p>
    <ul>
        <li>UICollectionViewDelegate: Gerencia a aparência e o comportamento da coleção.</li>
        <li>UICollectionViewDataSource: Gerencia os dados e fornece células para a coleção.</li>
        <li>UICollectionViewDelegateFlowLayout: Gerencia o layout das células (caso use UICollectionViewFlowLayout).</li>
    </ul>
    <p><strong>MÉTODOS PRINCIPAIS:</strong></p>
    <ul>
        <li><code>collectionView(_:cellForItemAt:)</code>: Fornece uma célula para cada item.</li>
        <li><code>collectionView(_:numberOfItemsInSection:)</code>: Retorna o número de itens em uma seção.</li>
        <li><code>numberOfSections(in:)</code>: Retorna o número de seções.</li>
        <li><code>collectionView(_:didSelectItemAt:)</code>: Lida com a seleção de itens.</li>
    </ul>
    <p>COMO MONTAR UMA UICollectionView:</p>
    <p>ADICIONANDO UICollectionView À INTERFACE</p>
    <p>NO INTERFACE BUILDER (STORYBOARD):</p>
    <ul>
        <li>Arraste um UICollectionView para a sua UIViewController.</li>
        <li>Configure as restrições (constraints) para definir o tamanho e a posição da coleção.</li>
        <li>Configure o layout da coleção adicionando um UICollectionViewFlowLayout.</li>
    </ul>
    <p>PROGRAMATICAMENTE:</p>
    <code>let layout = UICollectionViewFlowLayout()</code>
    <code>let collectionView = UICollectionView(frame: self.view.bounds, collectionViewLayout: layout)</code>
    <code>self.view.addSubview(collectionView)</code>
    <p>Configurando o Delegate e o DataSource:</p>
    <p>Conformar sua UIViewController aos protocolos UICollectionViewDelegate, UICollectionViewDataSource e UICollectionViewDelegateFlowLayout:</p>
    <code>class ViewController: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {</code>
    <p>// ...</p>
    <code>}</code>
    <p>Configurar o delegate e o dataSource:</p>
    <code>override func viewDidLoad() {</code>
    <code>super.viewDidLoad()</code>
    <code>collectionView.delegate = self</code>
    <code>collectionView.dataSource = self</code>
    <code>}</code>
    <p>IMPLEMENTANDO MÉTODOS REQUERIDOS</p>
    <p>UICollectionViewDataSource:</p>
    <code>func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {</code>
    <code>return items.count // Número de itens</code>
    <code>}</code>
    <p><code>func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {</code></p>
    <code>let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath)</code>
    <code>cell.contentView.backgroundColor = .red // Exemplo de configuração</code>
    <code>return cell</code>
    <code>}</code>
    <p>UICollectionViewDelegate (opcional):</p>
    <code>func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {</code>
    <code>print("Selecionou: \(items[indexPath.row])")</code>
    <code>}</code>
    <p>REGISTRANDO E CONFIGURANDO CÉLULAS</p>
    <p>Registrando uma célula padrão:</p>
    <code>collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: "cell")</code>
    <p>USANDO UMA CÉLULA PERSONALIZADA (no Storyboard):</p>
    <ul>
        <li>Crie uma UICollectionViewCell no Storyboard e defina um identificador.</li>
        <li>No método cellForItemAt, use o identificador para dequeuing:</li>
    </ul>
    <code>let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "customCell", for: indexPath) as! CustomCollectionViewCell</code>
    <p>FUNCIONALIDADES E DETALHES:</p>
    <p>LAYOUTS CUSTOMIZÁVEIS</p>
    <p>Usando UICollectionViewFlowLayout:</p>
    <code>func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {</code>
    <code>return CGSize(width: 100, height: 100)</code>
    <code>}</code>
    <p>Espaçamento entre células:</p>
    <code>func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {</code>
    <code>return 10</code>
    <code>}</code>
    <p><code>func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {</code></p>
    <code>return 10</code>
    <code>}</code>
    <p>Margens:</p>
    <code>func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {</code>
    <code>return UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)</code>
    <code>}</code>
    <p>CUSTOMIZAÇÃO DE CÉLULAS:</p>
    <p>Criando uma célula personalizada:</p>
    <code>class CustomCollectionViewCell: UICollectionViewCell {</code>
    <code>@IBOutlet weak var customLabel: UILabel!</code>
    <p>// Configurações adicionais</p>
    <code>}</code>
    <p>Configurando a célula no cellForItemAt:</p>
    <code>let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "customCell", for: indexPath) as! CustomCollectionViewCell</code>
    <code>cell.customLabel.text = items[indexPath.row]</code>
    <p>USOS PRÁTICOS:</p>
    <ul>
        <li>Grades de Imagens: Exibir galerias de fotos, álbuns ou catálogos de produtos.</li>
        <li>Layouts Customizados: Criar layouts complexos como mosaicos ou layouts inspirados em revistas.</li>
        <li>Interação Avançada: Implementar funcionalidades como arrastar e soltar, rolagem infinita e reordenamento de itens.</li>
        <li>Interfaces Ricas: Construir interfaces de usuário dinâmicas com células que incluem imagens, textos, botões e outros elementos.</li>
    </ul>
    <h3>EXEMPLO COMPLETO:</h3>
    <pre><code>import UIKit
        class ViewController: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
        @IBOutlet weak var collectionView: UICollectionView!
        
        let items = ["Item 1", "Item 2", "Item 3"]
        
        override func viewDidLoad() {
        super.viewDidLoad()
        collectionView.delegate = self
        collectionView.dataSource = self
        collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: "cell")
        }
        
        func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return items.count
        }
        
        func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath)
        cell.contentView.backgroundColor = .red
        return cell
        }
        
        func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        print("Selecionou: \(items[indexPath.row])")
        }
        
        func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        return CGSize(width: 100, height: 100)
        }
        
        func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return 10
        }
        
        func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {
        return 10
        }
        
        func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {
        return UIEdgeInsets(top: 10, left: 10, bottom: 10, right: 10)
        }
        }
        
    </code></pre>
    <h2>COMPARAÇÃO:</h2>
    <ul>
        <li>UITableView: Melhor para listas simples com rolagem vertical.</li>
        <li>UICollectionView: Melhor para layouts mais complexos, como grades ou layouts customizados, com rolagem horizontal ou vertical.</li>
    </ul>
